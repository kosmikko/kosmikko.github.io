<!DOCTYPE html><html lang="en"><head><!-- Meta--><meta charset="utf-8"><meta http-equiv="content-type" content="text/html; charset=utf-8"><title>Structuring complex Backbone.js apps | mikkolehtinen.com</title><meta name="description" content="When your website appears in search results in say Google, the text here will be shown underneath your website's title."><meta name="keywords" content="place, your, website, keywoards, here, keep, them, related, to, the, content, of, your, website"><meta name="author" content="Mikko Lehtinen"><meta http-equiv="X-Powered-By" content="DocPad"/><meta name="viewport" content="width=device-width"><!-- Icons--><link rel="shortcut icon" href="img/favicon.png"><!--[if lt IE 9]><script async src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script><![endif]--><!-- Styles--><link rel="stylesheet" href="/styles/monokai.css" /><link rel="stylesheet" href="/styles/main.css" /><link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" type="text/css"><link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" type="text/css"><script>var _gaq = _gaq || [];
_gaq.push(['_setAccount', "UA-18743700-1"]);
_gaq.push(['_trackPageview']);

(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();</script></head><body><header class="logo"><hgroup><h1><a href="/">mikkolehtinen.com</a></h1></hgroup></header><article id="maincolumn"><section id="content" class="content"><article class="post"><header><h1><a href="/blog/2012/08/03/structuring-complex-backbone-dot-js-apps/">Structuring complex Backbone.js apps</a></h1><p class="meta">Aug 03 2012</p></header><div class="page-content"><p>Building a more complex  JavaScript app can easily get out of hand if no effort is put into architecturing the application.  In this post I&#39;m overviewing some of the most common higher level architectural patterns and concerns that you should consider when building modular single page apps using Backbone.js.

</p>
<p>Transition from building traditional web apps doing full page reloads into dynamic single page app often requires rethinking the application architecture. You cannot just hack together some random jQuery code, because you&#39;re storing application state in client and managing it quickly becomes spaghetti. On the other end I&#39;ve seen some bad examples of <a href="http://www.johndcook.com/blog/2009/07/27/baklav-code/">over-engineering</a> your app, so think carefully what kind of architecture suits best for your app. 

</p>
<p>Single page apps should usually be architectured more like desktop apps, thus Smalltalk-80 like MVC fits quite naturally as a basis for modular, object-oriented application&#39;s architecture. MVC is only part of large application&#39;s architecture though - it only solves how to layer your modules into models, views and controllers.

</p>
<p>Backbone.js provides an easy starting point for MV* like structure, but it offers just mainly low-level patterns. What about bindings between objects, inter-module communication, dependency loading, handling  JST templates, view layouts, memory management and object disposal? The former are example issues that Backbone.js leaves open for the developer to implement. This has been a design choice with Backbone.js - it has small core but missing parts can be added as libraries when needed. 

</p>
<p>Now in the case of more complex application you could pick some of the more full stack frameworks, add some of the open source projects providing the missing parts on top of Backbone.js or build your own framework. There&#39;s always a tradeoff with large frameworks, e.g. ember.js provides much more out of the box but it&#39;s 20K LOC and opinionated. 

</p>
<p>I prefer a micro-framework approach where you have a small core framework and you can easily add additional libraries. Bindings, dependency loading, etc. higher level architectural issues are things that many developers disagree on how to implement those. Backbone.js leaves it open for developers mix and match components that suit their needs best, which is great.

</p>
<h2>Communication between objects and modules</h2>
<p>One key method for keeping application code maintainable is avoiding strong coupling between application modules. Loose coupling is good because it helps you to break your code into smaller and more maintainale blocks. This is much better option than strong coupling i.e. objects calling directly methods of other objects, which will slow down development and make your application difficult to maintain.

</p>
<p>One commonly used pattern to ensure loose coupling is the Observer pattern or Publish/Subscribe (Pub/Sub) pattern. This pattern uses an message(event) channel between the objects receiving notifications (subscribers) and the object firing the event (the publisher).  The publisher can then use event channel to inform all subscribers that something has happened.  This is very useful when building UI components, for example you can fire an event when a button was clicked and observers which could be other UI components can react to that event independently. 

</p>
<p>You can trigger events using <a href="http://backbonejs.org/#Events">Backbone.Events&#39;</a> <em>trigger</em>, subscribe to events with <em>on</em> and unsubscribe with <em>off</em>. But to achieve decoupling you need a mediator(middleman) between the publisher and subscribers, so that the objects don&#39;t need to know the details (such as lifetime) of others. Examples on how to implement mediator pattern see Addy Osmani&#39;s <a href="http://addyosmani.com/largescalejavascript/#mediatorpattern">patterns article</a> or Chaplin&#39;s <a href="https://github.com/chaplinjs/chaplin/blob/master/src/chaplin/mediator.coffee">mediator</a>. 

</p>
<p>I like to use the following naming conventions for subscribing an event:

</p>
<pre class="highlighted"><code class="javascript">mediator.subscribe(<span class="string">'module:action'</span>, <span class="keyword">this</span>.functionToCall);</code></pre>
<p>Thus subscriber&#39;s function <em>functionToCall</em> gets called when <em>&#39;module:action&#39;</em> event is triggered by a publisher. The publisher can publish the event with:

</p>
<pre class="highlighted"><code class="javascript">mediator.publish(<span class="string">'module:action'</span>, params);</code></pre>
<p>Here <em>&#39;module:action&#39;</em> is just a convention for the event channel. For example <em>&#39;login:dialogOpen&#39;</em> event could be fired when user opened the login dialog. This prefixing the action id with module name makes it a bit easier to track which module is triggering the event. For app wide global events I tend to use a prefix such as <em>&#39;global:globalEvent&#39;</em>.

</p>
<h2>Bindings and validation</h2>
<p>Object bindings are needed to keep properties between two different objects in sync, and making sure changes get propagated in either direction. Common use case for this pattern is binding your Model attributes to View elements. For example you want to change a form input when Model gets changed and update model based on user input. 

</p>
<p>Now this can be done with just <em>Backbone.Events</em>, but manually binding and unbinding events and re-rendering the view gets inefficient and causes bugs.  You will most likely want to use some of the open source libraries for handling automatic bindings. Check for example <a href="https://github.com/theironcook/Backbone.ModelBinder">Backbone.ModelBinder</a>.

</p>
<p>Another common need is validating Models based on form input and providing user feedback based on that. Backbone has a method for <a href="http://backbonejs.org/#Model-validate">Model validation</a>, but it is left blank and needs your custom validation logic. It makes sense to create reusable validation logic here. One good plugin for handling validation easily is <a href="https://github.com/thedersen/backbone.validation">backbone.validation</a>.

</p>
<h2>Template handling</h2>
<p>Use the templating engine of your choice (I&#39;m using <a href="http://handlebarsjs.com/">Handlebars.js</a>), if you don&#39;t like the syntax or features of the default Underscore templates.

</p>
<p>If performance is a concern, make sure that your template engine supports precompilation. That means that template is precompiled into JavaScript code, so that the client doesn&#39;t have to compile the template on the fly and you don&#39;t need to include the whole template engine code in your app. 

</p>
<p>You can do this precompilation step server side or when building the JavaScript files for production. See <a href="https://github.com/SlexAxton/require-handlebars-plugin">require-handlebars-plugin</a> for an example with Require.js and Handlebars. This plugin also provides other handy helpers such as automation for registering partials and helpers.

</p>
<p>Most server side precompilers e.g <a href="http://documentcloud.github.com/jammit/">Jammit</a> or <a href="http://nicolai86.eu/posts/2011-09-21/rails-3-asset-pipeline-javascript-templates/">Rails Asset Pipeline</a> will add compiled templates into top-level window.JST object.

</p>
<h2>View managment</h2>
<p>Backbone Views are very lightweight, so in almost any app you will need some helpers for view rendering, event binding, and lifecycle management. Usually it makes sense to subclass <em>Backbone.View</em> in your application&#39;s base View, and add the helpers there to be available for all Views.

</p>
<p>View&#39;s rendering helper takes care of mapping  JavaScript objects into DOM elements, otherwise writing this boilerplate manually per View gets tedious. Also rendering template into correct place in the UI should be abstracted. Most complex apps will need multiple screens with multiple subviews and manually managing subviews can lead to unmanageable code. 

</p>
<p>Lifecycle methods are needed for reacting into lifecycle events when needed, e.g. doing stuff after View is rendered or disposed. For example if you want to modify View&#39;s DOM, you can only do that after View is rendered.

</p>
<p>See <a href="https://github.com/derickbailey/backbone.marionette/blob/master/docs/marionette.view.md">Marionette&#39;s View</a>
or <a href="https://github.com/chaplinjs/chaplin/blob/master/src/chaplin/views/view.coffee">Chaplin&#39;s View</a> and if you&#39;re not using either pick the parts you need. Check also Rebecca Murphey&#39;s <a href="https://speakerdeck.com/u/rmurphey/p/new-dogs-old-tricks-or-dojo-already-did-that">deck</a> on this topic.

</p>
<h2>Memory management</h2>
<p>One major source for bugs in single page apps is memory leaks. Since you&#39;re not doing full page reloads to flush the memory, you&#39;ll need to be careful in correctly handling object disposal. Avoiding global variables is the basic thing to do, but you can still clutter memory with zombies if you don&#39;t clean up references after your objects correctly. Backbone.js does not  clean up objects for you, you need to make sure to de-reference your objects to let  JavaScript runtime&#39;s garbage collector do its job.

</p>
<p>Especially make sure to unbind from <em>Backbone.Events</em> when object is disposed. Common scenario is when switching Views in a region in your app, Backbone handles replacing the DOM with new view&#39;s content. But unless you correctly unbind the previous View from all events, it&#39;s left hanging around in memory still subscribed to the events.

</p>
<p>Good way to clean up memory after an object, is to implement some kind of automation for memory management in the lifecycle methods. For example setup conventions for calling a cleanup function before de-referencing the object. Chaplin objects have the <a href="https://github.com/chaplinjs/chaplin#memory-management-and-object-disposal">dispose method</a>, which in case of Views takes care of unbinding from all events and cleaning up View&#39;s subviews. Marionette.View has similar <a href="http://derickbailey.github.com/backbone.marionette/docs/backbone.marionette.html#section-19">close method</a>.

</p>
<h2>Conclusions</h2>
<p>Designing the perfect architecture for single page apps is not trivial. Think about the design goals for the architecture - you&#39;ll want the code to be clean, fast and maintainable. 

</p>
<p>Experience is the best way of learning on how to architecture apps, but you can also learn a lot from others. Backbone.js is probably not the easiest choice for beginners, since it leaves a lot of choices open to the developer. If you have no previous experiene in large single page apps, you should carefully study the architecture of the the more full stack MVC frameworks.

</p>
<p>If you decide to go with Backbone, see the design choices made in these Backbone based application frameworks:

</p>
<ul>
<li><a href="https://github.com/chaplinjs/chaplin">Chaplin</a></li>
<li><a href="http://walmartlabs.github.com/thorax/">Thorax</a></li>
<li><a href="https://github.com/derickbailey/backbone.marionette">Backbone.Marionette</a></li>
</ul>
<p>If you&#39;re not familiar with software design patterns I recommend reading still relevant <a href="http://en.wikipedia.org/wiki/Design_Patterns">Gang of Four&#39;s &quot;Design Patterns&quot;</a> or <a href="http://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420">&quot;Patterns of Enterprise Application Architecture&quot; by Martin Fowler</a>. Also Addy Osmani has written quite many <a href="http://addyosmani.com/largescalejavascript/">detailed</a> <a href="http://addyosmani.com/resources/essentialjsdesignpatterns/book/">articles</a> on patterns for large JavaScript applications.

</p>
<p>Join in the discussion on <a href="http://news.ycombinator.com/item?id=4334358">Hacker News</a></p>
</div><p class="postmeta"><span>Posted by Mikko Lehtinen</span><date>Aug 03 2012</date><span class="tags">Backbone.js,JavaScript,Architecture</span></p><div class="sharing"><a href="https://twitter.com/share" data-via="kosmikko" data-related="kosmikko" class="twitter-share-button">Tweet</a><script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script></div></article></section></article><aside id="sidebar"><section id="recent-posts"><h2>Recent posts</h2><ul><li><a href="/blog/2013-01-31-jenkins-setup-for-a-javascript-project">Jenkins setup for a JavaScript project</a></li><li><a href="/blog/2013/01/13/new-mac-setup/">Setting up a new Mac</a></li><li><a href="/blog/2012/08/03/structuring-complex-backbone-dot-js-apps/">Structuring complex Backbone.js apps</a></li><li><a href="/blog/2012/07/10/using-gnu-make-as-frontend-build-tool/">Using GNU Make as a frontend build tool</a></li><li><a href="/blog/2012/06/30/extending-backbone-views-using-mixins/">Extending Backbone views using mixins</a></li><li><a href="/blog/2012/05/25/rewindy-tech-stack/">Rewindy tech stack</a></li><li><a href="/blog/2012-05-16-migrated-to-octopress">Migrated to Octopress</a></li><li><a href="/blog/2010-11-05-cross-browser-buttons-with-css3-and-sass">Cross-browser buttons with CSS3 and Sass</a></li><li><a href="/blog/2010-10-28-app-engine-helpers-for-zsh">App Engine helpers for ZSH</a></li><li><a href="/blog/2010-10-26-markup-enabled-notational-velocity">Markup-enabled Notational Velocity</a></li><li><a href="/blog/2010-10-15-programmers-keyboard-layout">Programmer's keyboard layout</a></li><li><a href="/blog/2010-10-01-improving-kindle3-experience">Improving Kindle3 experience</a></li><li><a href="/blog/2010-09-24-osx-zsh-magic">OSX ZSH magic</a></li><li><a href="/blog/2010-09-24-decorator-for-executing-a-function-in-a-given-namespace">Decorator for executing a function in a given namespace</a></li></ul></section><section id="tweets"><h2>Latest tweets</h2><li><datetime>Jan 29 2013</datetime><a href="https://twitter.com/#!/kosmikko/status/296254455345737728" title="View on Twitter">Full-Spectrum Testing with AngularJS and Testacular http://t.co/6Zr6w1aE</a></li><li><datetime>Jan 29 2013</datetime><a href="https://twitter.com/#!/kosmikko/status/296176247141195776" title="View on Twitter">gr8, sublime text 3 beta available for reg users http://t.co/a8iJpU3u</a></li><li><datetime>Jan 28 2013</datetime><a href="https://twitter.com/#!/kosmikko/status/295891774524755968" title="View on Twitter">Helium - A minimal &amp; responsive frontend framework based on Bootstrap &amp; Foundation https://t.co/IFURd0Tq</a></li><li><datetime>Jan 28 2013</datetime><a href="https://twitter.com/#!/kosmikko/status/295885167917158401" title="View on Twitter">kelly norton: On Layout &amp; Web Performance http://t.co/Aa4lqWj2 via @kellegous</a></li><li><datetime>Jan 25 2013</datetime><a href="https://twitter.com/#!/kosmikko/status/294709999668711424" title="View on Twitter">The future of agile development - Do the right things right and fast http://t.co/nqYA1yta</a></li></section></aside><!-- Scripts--></body></html>